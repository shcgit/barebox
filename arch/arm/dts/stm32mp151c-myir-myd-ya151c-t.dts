// SPDX-License-Identifier: GPL-2.0-or-later
/* SPDX-FileCopyrightText: Alexander Shiyan, <shc_work@mail.ru> */

/dts-v1/;

#include <dt-bindings/net/qca-ar803x.h>

#include <arm/stm32mp151.dtsi>
#include "stm32mp15xc-myir-myc-ya15xc-t.dtsi"

/ {
	model = "MYIR MYD-YA151C-T";
	compatible = "myir,myd-ya151c-t", "st,stm32mp151";

	aliases {
		ethernet0 = &ethernet0;
		i2c1 = &i2c2;
		serial0 = &uart4;
		spi4 = &spi5;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	backlight: backlight {
		compatible = "pwm-backlight";
		pwms = <&pwm2 0 100000 0>;
		brightness-levels = <0 255>;
		num-interpolated-steps = <256>;
		default-brightness-level = <255>;
	};

	panel: panel {
		compatible = "innolux,at070tn92";
		backlight = <&backlight>;
		enable-gpios = <&gpioi 3 (GPIO_ACTIVE_HIGH | GPIO_PUSH_PULL)>;
		power-supply = <&vdd_3v3>;

		port {
			panel_in: endpoint {
				remote-endpoint = <&ltdc_out>;
			};
		};
	};

	vin: regulator-vin {
		compatible = "regulator-fixed";
		regulator-name = "vin";
		regulator-min-microvolt = <5000000>;
		regulator-max-microvolt = <5000000>;
		regulator-always-on;
	};

	vdd_3v3: regulator-vdd-3v3 {
		compatible = "regulator-fixed";
		regulator-name = "vdd_3v3";
		regulator-min-microvolt = <3300000>;
		regulator-max-microvolt = <3300000>;
		regulator-always-on;
		vin-supply = <&v3v3>;
	};
};

&leds {
	led_live: led-live {
		label = "board:live";
		color = <LED_COLOR_ID_BLUE>;
		default-state = "off";
		function = LED_FUNCTION_HEARTBEAT;
		gpios = <&extgpio 4 GPIO_ACTIVE_LOW>;
		linux,default-trigger = LED_FUNCTION_HEARTBEAT;
		panic-indicator;
	};
};

&vin_som {
	vin-supply = <&vin>;
};

&i2c2 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c2_pins &i2c2_pins_z>;
	pinctrl-1 = <&i2c2_sleep_pins &i2c2_sleep_pins_z>;
	clock-frequency = <400000>;
	status = "okay";

	extgpio: gpio@20 {
		compatible = "nxp,pcf8575";
		reg = <0x20>;
		gpio-controller;
		#gpio-cells = <2>;
	};

	typec: usb@28 {
		pinctrl-names = "default";
		pinctrl-0 = <&stusb1600_pins>;
		compatible = "st,stusb1600";
		reg = <0x28>;
		interrupt-parent = <&gpioa>;
		interrupts = <10 IRQ_TYPE_EDGE_FALLING>;
		vdd-supply = <&vin>;
		vsys-supply = <&vdd_3v3>;

		connector {
			compatible = "usb-c-connector";
			label = "USB-C";
			data-role = "dual";
			power-role = "dual";
			typec-power-opmode = "default";

			port {
				typec_ep: endpoint {
					remote-endpoint = <&usbotg_hs_ep>;
				};
			};
		};
	};

	rx8025: rtc@32 {
		compatible = "epson,rx8025";
		reg = <0x32>;
	};
};

&ethernet0 {
	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
	pinctrl-names = "default", "sleep";
	phy-handle = <&phy0>;
	phy-mode = "rgmii-id";
	max-speed = <1000>;
	nvmem-cells = <&macaddr0>;
	nvmem-cell-names = "mac-address";
	status = "okay";

	mdio {
		compatible = "snps,dwmac-mdio";
		reset-gpios = <&gpiog 3 (GPIO_ACTIVE_LOW | GPIO_PUSH_PULL)>;
		reset-delay-us = <10000>;
		reset-post-delay-us = <2000>;

		#address-cells = <1>;
		#size-cells = <0>;

		phy0: phy@6 {
			reg = <6>;
			qca,clk-out-frequency = <125000000>;
			qca,clk-out-strength = <AR803X_STRENGTH_FULL>;
		};
	};
};

&ltdc {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&ltdc_pins>;
	pinctrl-1 = <&ltdc_sleep_pins>;
	status = "okay";

	port {
		ltdc_out: endpoint {
			remote-endpoint = <&panel_in>;
		};
	};
};

&sai1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&sai1_pins>;
	pinctrl-1 = <&sai1_sleep_pins>;
	clocks = <&rcc SAI1>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
	clock-names = "pclk", "x8k", "x11k";
	status = "okay";
};

&sai1b {
	dma-names = "tx";
	status = "okay";
};

&sdmmc1 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc1_b4_pins_a>;
	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
	cd-gpios = <&gpioa 3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	disable-wp;
	st,neg-edge;
	vmmc-supply = <&vdd>;
	status = "okay";
};

&spi5 {
	pinctrl-names = "default";
	pinctrl-0 = <&spi5_pins>;
	cs-gpios = <&gpioh 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>,
		   <&gpiof 13 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
	status = "okay";
};

&timers2 {
	status = "okay";

	pwm2: pwm {
		pinctrl-names = "default", "sleep";
		pinctrl-0 = <&tim2_pwm_pins>;
		pinctrl-1 = <&tim2_pwm_sleep_pins>;
		status = "okay";
	};
};

&uart4 {
	pinctrl-names = "default", "sleep", "idle";
	pinctrl-0 = <&uart4_pins>;
	pinctrl-1 = <&uart4_sleep_pins>;
	pinctrl-2 = <&uart4_idle_pins>;
	status = "okay";
};

&usbh_ehci {
	phys = <&usbphyc_port0>;
	phy-names = "usb";
	status = "okay";
};

&usbotg_hs {
	phys = <&usbphyc_port1 0>;
	phy-names = "usb2-phy";
	usb-role-switch;
	vbus-supply = <&vbus_otg>;
	status = "okay";

	port {
		usbotg_hs_ep: endpoint {
			remote-endpoint = <&typec_ep>;
		};
	};
};

&usbphyc {
	status = "okay";
};

&usbphyc_port0 {
	phy-supply = <&vdd_usb>;
	st,tune-hs-dc-level = <2>;
	st,enable-fs-rftime-tuning;
	st,enable-hs-rftime-reduction;
	st,trim-hs-current = <15>;
	st,trim-hs-impedance = <1>;
	st,tune-squelch-level = <3>;
	st,tune-hs-rx-offset = <2>;
	st,no-lsfs-sc;

	connector {
		compatible = "usb-a-connector";
		vbus-supply = <&vin>;
	};
};

&usbphyc_port1 {
	phy-supply = <&vdd_usb>;
	st,tune-hs-dc-level = <2>;
	st,enable-fs-rftime-tuning;
	st,enable-hs-rftime-reduction;
	st,trim-hs-current = <15>;
	st,trim-hs-impedance = <1>;
	st,tune-squelch-level = <3>;
	st,tune-hs-rx-offset = <2>;
	st,no-lsfs-sc;
};

&pinctrl {
	i2c2_pins: i2c2-0 {
		pins {
			pinmux = <STM32_PINMUX('H', 4, AF4)>;		/* I2C2_SCL */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c2_sleep_pins: i2c2-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('H', 4, ANALOG)>;	/* I2C2_SCL */
		};
	};

	ltdc_pins: ltdc-0 {
		pins {
			pinmux = <STM32_PINMUX('G',  7, AF14)>,		/* LCD_CLK */
				 <STM32_PINMUX('I', 10, AF14)>,		/* LCD_HSYNC */
				 <STM32_PINMUX('I',  9, AF14)>,		/* LCD_VSYNC */
				 <STM32_PINMUX('E', 13, AF14)>,		/* LCD_DE */
				 <STM32_PINMUX('H',  2, AF14)>,		/* LCD_R0 */
				 <STM32_PINMUX('H',  3, AF14)>,		/* LCD_R1 */
				 <STM32_PINMUX('H',  8, AF14)>,		/* LCD_R2 */
				 <STM32_PINMUX('H',  9, AF14)>,		/* LCD_R3 */
				 <STM32_PINMUX('H', 10, AF14)>,		/* LCD_R4 */
				 <STM32_PINMUX('H', 11, AF14)>,		/* LCD_R5 */
				 <STM32_PINMUX('H', 12, AF14)>,		/* LCD_R6 */
				 <STM32_PINMUX('E', 15, AF14)>,		/* LCD_R7 */
				 <STM32_PINMUX('E', 14, AF14)>,		/* LCD_G0 */
				 <STM32_PINMUX('E',  6, AF14)>,		/* LCD_G1 */
				 <STM32_PINMUX('H', 13, AF14)>,		/* LCD_G2 */
				 <STM32_PINMUX('H', 14, AF14)>,		/* LCD_G3 */
				 <STM32_PINMUX('H', 15, AF14)>,		/* LCD_G4 */
				 <STM32_PINMUX('I',  0, AF14)>,		/* LCD_G5 */
				 <STM32_PINMUX('I',  1, AF14)>,		/* LCD_G6 */
				 <STM32_PINMUX('I',  2, AF14)>,		/* LCD_G7 */
				 <STM32_PINMUX('D',  9, AF14)>,		/* LCD_B0 */
				 <STM32_PINMUX('G', 12, AF14)>,		/* LCD_B1 */
				 <STM32_PINMUX('G', 10, AF14)>,		/* LCD_B2 */
				 <STM32_PINMUX('D', 10, AF14)>,		/* LCD_B3 */
				 <STM32_PINMUX('I',  4, AF14)>,		/* LCD_B4 */
				 <STM32_PINMUX('I',  5, AF14)>,		/* LCD_B5 */
				 <STM32_PINMUX('I',  6, AF14)>,		/* LCD_B6 */
				 <STM32_PINMUX('I',  7, AF14)>;		/* LCD_B7 */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
		};
	};

	ltdc_sleep_pins: ltdc-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('G',  7, ANALOG)>,	/* LCD_CLK */
				 <STM32_PINMUX('I', 10, ANALOG)>,	/* LCD_HSYNC */
				 <STM32_PINMUX('I',  9, ANALOG)>,	/* LCD_VSYNC */
				 <STM32_PINMUX('E', 13, ANALOG)>,	/* LCD_DE */
				 <STM32_PINMUX('H',  2, ANALOG)>,	/* LCD_R0 */
				 <STM32_PINMUX('H',  3, ANALOG)>,	/* LCD_R1 */
				 <STM32_PINMUX('H',  8, ANALOG)>,	/* LCD_R2 */
				 <STM32_PINMUX('H',  9, ANALOG)>,	/* LCD_R3 */
				 <STM32_PINMUX('H', 10, ANALOG)>,	/* LCD_R4 */
				 <STM32_PINMUX('H', 11, ANALOG)>,	/* LCD_R5 */
				 <STM32_PINMUX('H', 12, ANALOG)>,	/* LCD_R6 */
				 <STM32_PINMUX('E', 15, ANALOG)>,	/* LCD_R7 */
				 <STM32_PINMUX('E', 14, ANALOG)>,	/* LCD_G0 */
				 <STM32_PINMUX('E',  6, ANALOG)>,	/* LCD_G1 */
				 <STM32_PINMUX('H', 13, ANALOG)>,	/* LCD_G2 */
				 <STM32_PINMUX('H', 14, ANALOG)>,	/* LCD_G3 */
				 <STM32_PINMUX('H', 15, ANALOG)>,	/* LCD_G4 */
				 <STM32_PINMUX('I',  0, ANALOG)>,	/* LCD_G5 */
				 <STM32_PINMUX('I',  1, ANALOG)>,	/* LCD_G6 */
				 <STM32_PINMUX('I',  2, ANALOG)>,	/* LCD_G7 */
				 <STM32_PINMUX('D',  9, ANALOG)>,	/* LCD_B0 */
				 <STM32_PINMUX('G', 12, ANALOG)>,	/* LCD_B1 */
				 <STM32_PINMUX('G', 10, ANALOG)>,	/* LCD_B2 */
				 <STM32_PINMUX('D', 10, ANALOG)>,	/* LCD_B3 */
				 <STM32_PINMUX('I',  4, ANALOG)>,	/* LCD_B4 */
				 <STM32_PINMUX('I',  5, ANALOG)>,	/* LCD_B5 */
				 <STM32_PINMUX('I',  6, ANALOG)>,	/* LCD_B6 */
				 <STM32_PINMUX('I',  7, ANALOG)>;	/* LCD_B7 */
		};
	};

	sai1_pins: sai1-0 {
		pins1 {
			pinmux = <STM32_PINMUX('F', 6, AF6)>;		/* SAI1_SD_B */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('F', 8, AF6)>,		/* SAI1_SCK_B */
				 <STM32_PINMUX('F', 9, AF6)>;		/* SAI1_FS_B */
			bias-disable;
		};
	};

	sai1_sleep_pins: sai1-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('F', 6, ANALOG)>,	/* SAI1_SD_B */
				 <STM32_PINMUX('F', 8, ANALOG)>,	/* SAI1_SCK_B */
				 <STM32_PINMUX('F', 9, ANALOG)>;	/* SAI1_FS_B */
		};
	};

	spi5_pins: spi5-0 {
		pins {
			pinmux = <STM32_PINMUX('H', 6, AF5)>,		/* SPI5_SCK */
				 <STM32_PINMUX('F', 11, AF5)>;		/* SPI5_MOSI */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('H', 7, AF5)>;		/* SPI5_MISO */
			bias-disable;
		};
	};

	stusb1600_pins: stusb1600-0 {
		pins {
			pinmux = <STM32_PINMUX('A', 10, ANALOG)>;	/* STUSB1600 IRQ */
			bias-pull-up;
		};
	};

	tim2_pwm_pins: tim2-pwm-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 8, AF1)>;		/* TIM2_CH1 */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
	};

	tim2_pwm_sleep_pins: tim2-pwm-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('G', 8, ANALOG)>;	/* TIM2_CH1 */
		};
	};

	uart4_pins: uart4-0 {
		pins1 {
			pinmux = <STM32_PINMUX('G', 11, AF6)>;		/* UART4_TX */
			bias-disable;
			drive-push-pull;
			slew-rate = <0>;
		};
		pins2 {
			pinmux = <STM32_PINMUX('A', 11, AF6)>;		/* UART4_RX */
			bias-disable;
		};
	};

	uart4_idle_pins: uart4-idle-0 {
		pins1 {
			pinmux = <STM32_PINMUX('G', 11, ANALOG)>;	/* UART4_TX */
		};
		pins2 {
			pinmux = <STM32_PINMUX('A', 11, AF6)>;		/* UART4_RX */
			bias-disable;
		};
	};

	uart4_sleep_pins: uart4-sleep-0 {
		pins1 {
			pinmux = <STM32_PINMUX('G', 11, ANALOG)>,	/* UART4_TX */
				 <STM32_PINMUX('A', 11, ANALOG)>;	/* UART4_RX */
		};
	};
};

&pinctrl_z {
	i2c2_pins_z: i2c2-0 {
		pins {
			pinmux = <STM32_PINMUX('Z', 7, AF3)>;		/* I2C2_SDA */
			bias-disable;
			drive-open-drain;
			slew-rate = <0>;
		};
	};

	i2c2_sleep_pins_z: i2c2-sleep-0 {
		pins {
			pinmux = <STM32_PINMUX('Z', 7, ANALOG)>;	/* I2C2_SDA */
		};
	};
};
